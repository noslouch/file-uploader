/*!
 * Implementing the FileReader API for a user-friendly file upload interface.
 * Backwards compatability provided by FileReader Polyfill
 * https://github.com/Jahdrien/FileReader
 *
 * This UX interface is built using an Uploader constructure that is initiated 
 * by the file picker change event.
 * A special ImageUploader inherits from Uploader and adds image preview
 * functionality using the FileReader API or the FileReader Polyfill.
 * 
 * The Polyfill will not attach any picked files to a form to (as  $_FILES
 * object, for instance), so the file must be attached in another way. This
 * interface converts chosen files to Base64 and attaches the appropriate FileList
 * data (Name, Type, Size) as hidden inputs. This is done using a Mixin that is
 * called if !Modernizr.filereader.
 *
 * - BW
 */

// helpful debuggers
function log(a){
    if (!window.console){return false}
    console.log(a)
}

function dir(a){
    if (!window.console){return false}
    console.dir(a)
}

// helpful variables
app = {
    // these four elements are used with image previews
    $sizeEl : $('<span/>').addClass('size').attr('id','size'),
    $nameEl : $('<span/>').addClass('filename').attr('id','filename'),
    $clearButton : $('<button/>').attr({'class':'clear','id':'clear','type':'button'}).html('Clear'),
    preview : document.getElementById('preview'),

    // using the 'begin' class, we can show or hide a progres indicator during various events
    loader : document.getElementById('loading'),

    // we'll hold pointers to the hidden inputs generated by our mixin here, so we can easily
    // remove them if need be
    oldInputs: [],

    form : document.getElementById('post-form'),
    $inputs : $('input[type=file]'),
    
    // the lowest common parent to all file inputs
    uploads : document.getElementById('upload-buttons'),

    // page init. inputs start disabled to prevent submitting before dependencies load
    init : function(){
        log('init')
        app.$inputs.prop('disabled', false)
        app.$inputs.parent().removeClass('disabled')
        $(app.loader).removeClass('begin')
        $('#submitBtn').prop('disabled', false)
    }
}

Modernizr.load([{
    test: Modernizr.filereader,
    nope : ['js/jquery-ui/jquery-ui-position.js', 'js/filereader/jquery.FileReader.js', 'js/swfobject/swfobject.js' ],
    complete : function(){
        $(app.loader).addClass('begin')

        if (!Modernizr.filereader){
            log('filereader not supported')

            app.$inputs.fileReader({
                id : 'fileReaderSWF',
                filereader : 'js/filereader/filereader.swf',
                expressInstall : 'js/swfobject/expressInstall.swf',
                debugMode : true,
                callback : app.init
            })
        } else {
            app.init()
        }
    }
}])

// base constructor for all file uploads
function Uploader(e){
    log('initializing uploader')
    this.file = e.files[0]
    this.input = e

    // File size checking is handled higher in the prototype chain, so this flag
    // tracks if a file is too large and allows ImageUploader instances to access
    // the result
    this.imageFlag = true

    if (!this.sizeCheck(this.file)){
        log('file too big')
        this.imageFlag = false
        return false
    } 
    if (!Modernizr.filereader){
        polyfillMixin.call(this)
    }

    this.disableOthers(this.input)
}

// compares filesize to limits
Uploader.prototype.sizeCheck = function(){ 
    log('sizeCheck: checking file size')
    var redableLimit, rawLimit, limit, id
    var size = this.getSize(this.file.size)
    
    if (this.file.type.match("image")) {
        rawLimit = 2500000
        limit = '2.5 MB'
        id = 'images'
    } else if (this.file.type.match("audio")) {
        rawLimit = 5000000
        limit = '5 MB'
        id = 'audio clips'
    } else if (this.file.type.match("video")) {
        rawLimit = 15000000
        limit = '15 MB'
        id = 'videos'
    } else {
        alert('Only image, video, and audio file types are allowed.')
        return false
    }
    
    if (this.file.size > rawLimit) {
        readableLimit = this.getSize(rawLimit)
        this.clearMedia()
        app.$sizeEl.text('Sorry, but the maximum file size for ' + id + ' is ' + readableLimit + '. ' + this.file.name + ' is ' + size).prependTo('.specs')
        return false
    } else {
        this.showSpecs(size)
        return true
    }   
}

// do the math to convert from bytes to readable formats
Uploader.prototype.getSize = function(size){ 
    log('getSize: converting file size')
    var nBytes = size
    var output = nBytes + ' bytes'
    for (var multiples = ['KB', 'MB'], n = 0, approx = nBytes/1024; approx > 1; approx /= 1024, n++) {
        output = approx.toFixed(2) + ' ' + multiples[n]
    }
    
    return output  
}

// injects file name and size into DOM
Uploader.prototype.showSpecs = function(size){ 
    log('showSpecs: display file specs in DOM')
    app.$sizeEl.text(size).prependTo('.specs')
    app.$nameEl.text(this.file.name + ': ').prependTo('.specs')
    $(app.preview).append(app.$clearButton)
}

// clear file inputs, any image previews, and any hidden inputs generated by mixin
// this is where oldInputs comes in 
Uploader.prototype.clearMedia = function(){ 

    app.$inputs.val('').prop('disabled', false)
    app.$inputs.parent().removeClass('disabled')

    $(app.preview).find('img, #size, #filename').remove()
    
    if (!!app.oldInputs) {
        $(app.oldInputs).remove()
    }
    if (!!app.oldPhoto) {
        // Regular Post
        $(app.preview).append(oldPhoto)   
    } else {
        // Profile setup
        $(app.preview).removeClass('loaded')
    }
}

// disables other file inputs after user chooses one for upload
// this makes server processing simpler, since disabled inputs
// do not get sent with the form
Uploader.prototype.disableOthers = function(self){ 
    log('disabling others')
    var $notSelected = $('input[type=file]').not(self)
    $notSelected.parent().addClass('disabled')
    $notSelected.prop('disabled', true)
}

// Specialized ImageUploader constructor
function ImageUploader(input){
    // saving this into self to use inside event handlers
    var self = this
    var r = this.reader = this.reader || new FileReader()
    var img = this.image = new Image()

    $(app.loader).addClass('begin')

    // inherit Uploader constructor initialization
    Uploader.call(this, input)

    // file size checking is handled higher in the prototype chain
    // this prototype property lets us check the results down the line
    if (!this.imageFlag){
        $(app.loader).removeClass('begin')
        return false
    }

    // handle FileReader events with jQuery so we can add to the event
    // chain without overriding additional steps by polyfill mixin
    $(r).on('load', function(event) {
        img.src = event.target.result
    })

    $(r).on('loadend', function() {
        $(app.loader).removeClass('begin')
    })

    img.onload = function(){
        self.imagePreview(this)
    }
    r.readAsDataURL(this.file)
}

// add Uploader methods to ImageUploader
ImageUploader.prototype = Object.create(Uploader.prototype)

// injects image preview into DOM
ImageUploader.prototype.imagePreview = function(img){ 
    $(app.preview).find('.thumb').prepend(img)
    $(app.preview).addClass('loaded')
}

// This mixin should be called with the Uploader constructor as its context
// This grabs the chosen file provided by the FileReader Polyfill and attaches
// the adata to an array of hidden inputs that can be sent to the server.
// This data will be sent in the $_POST array.
function polyfillMixin(){
    $('#submitBtn').prop('disabled', true)
    $(app.loader).addClass('begin')

    var uploader = this
    var r = uploader.reader = uploader.reader || new FileReader()
    var file = uploader.file
    var inputName = file.input
    var props = {}

    // fix input reference to be used by disableOthers
    this.input = document.getElementsByName(file.input)

    props['name'] = file.name
    props['type'] = file.type
    props['size'] = file.size

    function attachFile(){    
        app.oldInputs = []
        
        // loop through file's properties and attach them as hidden inputs
        for (prop in props) {
            var toPHP = document.createElement('input')
            if (props.hasOwnProperty(prop)) {
                toPHP.type = 'hidden'
                toPHP.name = inputName + '['+prop+']'
                toPHP.value = props[prop]
                app.form.appendChild(toPHP)
                app.oldInputs.push(toPHP)
            }
        }
    }

    $(r).on('load', function(e){
        // this will be the base64 string representation fo the file
        props.data = e.target.result
    })
    $(r).on('loadend', function(e){
        attachFile()
        $(app.loader).removeClass('begin')
        $('#submitBtn').prop('disabled', false)
    })
    
    // ImageUploaders always call readAsDataURL to generate image previews
    // so we check to keep from doing double read outs of the file
    if (!(this instanceof ImageUploader)){
        r.readAsDataURL(this.file)
    }
}


$(function(){

    // the h5bp visuallyhidden class and triggering the click event on the file
    // picker input causes issues in older browsers and the polyfill.
    // there is a fall back SASS mixin called file-blanket that keeps the input
    // hidden from the userw while maintaining functionality.
    $fallback = $('.no-filereader input[type=file]')
    $fallback.removeClass('visuallyhidden')

    // trigger click event on hidden file inputs from styled buttons
    $('.filereader #upload-buttons').on('click', 'button', function(e){
        $(this).siblings('input').click()
    })

    $(app.uploads).on('change', null, function(e){ 
        if (e.target.files[0].type.match("image/*")){
            uploader = new ImageUploader(e.target)
        } else {
            uploader = new Uploader(e.target)
        }
    })

    $(app.preview).on('click', '#clear', function(evt){
        try {
            uploader.clearMedia(app.oldPhoto)
        } catch(e){
            uploader.clearMedia()
        }
        $(evt.target).detach()
    })

    $('#post-form').submit(function(e){
        $(app.loader).addClass('begin')
        $('#submitBtn').prop('disabled', true)
        // a more reliable way to prevent duplicate submissions on a form
        $(this).submit(function(){return false})
        return true
    })
})    
